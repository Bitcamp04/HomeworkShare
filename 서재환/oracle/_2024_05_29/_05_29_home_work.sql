--1) 어제 만든 SCORE_STGR 테이블의 SNO 컬럼에 INDEX를 추가하세요.
CREATE INDEX SNO_INDEX ON SCORE_STGR(SNO); 
COMMIT;

--2) 어제 만든 ST_COURSEPF 테이블의 SNO, CNO, PNO 다중 컬럼에 INDEX를 추가하세요.
CREATE INDEX ST_COURSEPF_SNO_CNO_PNO_INDEX ON ST_COURSEPF(SNO,CNO,PNO);
COMMIT ;

--뷰 이름은 자유
--1) 학생의 평점 4.5 만점으로 환산된 정보를 검색할 수 있는 뷰를 생성하세요.
CREATE VIEW A (
	SNO,
	SNAME,
	AVR
)
AS
(
	SELECT SNO,SNAME,(AVR*4.5/4.0)
	FROM STUDENT 
);

--2) 각 과목별 기말고사 평균 점수를 검색할 수 있는 뷰를 생성하세요.
CREATE VIEW B (
	CNO,
	CNAME,
	AVR_RESULT
)
AS
(
	SELECT C.CNO,C.CNAME,AVG(SC.RESULT)
	FROM COURSE C
	JOIN SCORE SC
	ON C.CNO=SC.CNO
	GROUP BY C.CNO,C.CNAME
);
COMMIT;
--3) 각 사원과 관리자(MGR)의 이름을 검색할 수 있는 뷰를 생성하세요.
CREATE VIEW C (
	ENO,
	ENAME,
	MGR_NO,
	MGR_NAME
)
AS
(
	SELECT E1.ENO,E1.ENAME,E2.ENO,E2.ENAME
	FROM EMP E1
	JOIN EMP E2
	ON E1.MGR = E2.ENO
);
COMMIT;
--4) 각 과목별 기말고사 평가 등급(A~F)까지와 해당 학생 정보를 검색할 수 있는 뷰를 생성하세요.
CREATE VIEW D (
	CNO,
	CNAME,
	SNO,
	SNAME,
	SYEAR,
	GRADE
)
AS
(
	SELECT C.CNO,C.CNAME,ST.SNO,ST.SNAME,ST.SYEAR,SR.GRADE
	FROM STUDENT ST
	JOIN SCORE SC
	ON SC.SNO = ST.SNO
	JOIN COURSE C
	ON C.CNO = SC.CNO
	JOIN SCGRADE SR
	ON SC.RESULT BETWEEN SR.LOSCORE AND SR.HISCORE
);
COMMIT;

--5) 물리학과 교수의 과목을 수강하는 학생의 명단을 검색할 뷰를 생성하세요.
CREATE VIEW E  (
	SNO,
	SNAME,
	SYEAR
)
AS
(
	SELECT ST.SNO,ST.SNAME,ST.SYEAR
	FROM PROFESSOR P
	JOIN COURSE C
	ON P.PNO = C.PNO
	JOIN SCORE SC
	ON C.CNO = SC.CNO
	JOIN STUDENT ST
	ON ST.SNO=SC.SNO
	WHERE P.SECTION = '물리'
);
COMMIT;

--1) 4.5 환산 평점이 가장 높은 3인의 학생을 검색하세요.

SELECT *
FROM (SELECT * FROM A ORDER BY AVR DESC)
WHERE ROWNUM <=3;

--2) 기말고사 과목별 평균이 높은 3과목을 검색하세요.
SELECT *
FROM (SELECT * FROM B ORDER BY AVR_RESULT DESC)
WHERE ROWNUM <=3;

--3) 학과별, 학년별, 기말고사 평균이 순위 3까지를 검색하세요.(학과, 학년, 평균점수 검색)
SELECT *
FROM (
	SELECT ST.MAJOR,ST.SYEAR,AVG(SC.RESULT) 
	FROM STUDENT ST
	JOIN SCORE SC
	ON ST.SNO = SC.SNO
	GROUP BY GROUPING SETS(ST.MAJOR,ST.SYEAR)
)

--4) 기말고사 성적이 높은 과목을 담당하는 교수 3인을 검색하세요.(교수이름, 과목명, 평균점수 검색)
SELECT *
FROM PROFESSOR P
JOIN COURSE C
ON P.PNO = C.PNO
JOIN
(
SELECT C.CNO,AVG(SC."RESULT") 
FROM COURSE C
JOIN SCORE SC
ON C.CNO = SC.CNO 
GROUP BY C.CNO
ORDER BY AVG(SC."RESULT") DESC
)A
ON A.CNO=C.CNO
WHERE ROWNUM<=3;
--5) 교수별로 현재 수강중인 학생의 수를 검색하세요.
SELECT P.PNO,P.PNAME,COUNT(ST.SNO)
FROM PROFESSOR P
LEFT JOIN COURSE C
ON C.PNO = P.PNO
LEFT JOIN SCORE SC
ON C.CNO = SC.CNO 
LEFT JOIN STUDENT ST
ON ST.SNO =SC.SNO
GROUP BY P.PNO ,P.PNAME ;


--1) CNO이 PK인 COURSE_PK 테이블을 생성하세요.(1번 방식으로)
CREATE TABLE COURSE_PK (
	CNO VARCHAR2 (8) CONSTRAINT COURSE_CNO_PK PRIMARY KEY,
	CNAME VARCHAR2 (20),
	ST_NUM NUMBER (1,0),
	PNO VARCHAR2 (8)
);

--2) PNO이 PK인 PROFESSOR_PK 테이블을 생성하세요.(2번 방식으로)
CREATE TABLE PROFESSOR_PK (
	PNO VARCHAR2 (8),
	PNAME VARCHAR2 (20),
	SECTION VARCHAR2 (20),
	ORDERS VARCHAR2 (10),
	HIREDATE DATE,
	CONSTRAINT PROFESSOR_PNO_PK PRIMARY KEY(PNO)
)

CREATE TABLE PF_TEMP AS  
SELECT *
FROM PROFESSOR ;
COMMIT;
--3) PF_TEMP 테이블에 PNO을 PK로 추가하세요.
ALTER TABLE PF_TEMP ADD CONSTRAINT PF_TEMP_PNO_PK PRIMARY KEY(PNO);

CREATE TABLE COURES_PRFESSOR_MODIFY AS
SELECT C.CNO,C.CNAME,P.PNO,P.PNAME
FROM PROFESSOR P
JOIN COURSE C
ON P.PNO = C.PNO;
COMMIT;
--4) COURES_PRFESSOR_MODIFY 테이블에 CNO, PNO을 PK로 추가하세요.
ALTER TABLE COURES_PRFESSOR_MODIFY ADD CONSTRAINT COURSE_PROFESSOR_CNO_PNO_PK PRIMARY KEY(CNO,PNO);

--5) BOARD_NO(NUMBER)를 PK로 갖으면서 BOARD_TITLE(VARCHAR2(200)), BOARD_CONTENT(VARCHAR2(2000)), 
--   BOARD_WRITER(VARCHAR2(20)), BOARD_FRGT_DATE(DATE), BOARD_LMDF_DATE(DATE) 컬럼을 갖는 T_BOARD 테이블을 생성하세요.
CREATE TABLE T_BOARD(
	BOARD_NO NUMBER ,
	BOARD_TITLE VARCHAR2(200),
	BOARD_CONTENTN VARCHAR2(2000), 
	BOARD_WRITER VARCHAR2(20),
	BOARD_FRGT_DATE DATE, 
	BOARD_LMDF_DATE DATE,
	CONSTRAINT T_BOARD_BOARD_NO_PK PRIMARY KEY(BOARD_NO)
) ;
COMMIT ;

--6) BOARD_NO(NUMBER), BOARD_FILE_NO(NUMBER)를 PK로 갖으면서 BOARD_FILE_NM(VARCHAR2(200)), BOARD_FILE_PATH(VARCHAR2(2000)),
--   ORIGIN_FILE_NM(VARCHAR2(200)) 컬럼을 갖는 T_BOARD_FILE 테이블을 생성하세요.
CREATE TABLE T_BOARD_FILE(
	BOARD_NO NUMBER, 
	BOARD_FILE_NO NUMBER,
	BOARD_FILE_NM VARCHAR2(200), 
	BOARD_FILE_PATH VARCHAR2(2000),
	ORIGIN_FILE_NM VARCHAR2(200),
	CONSTRAINT T_BOARD_FILE_PK PRIMARY KEY(BOARD_NO,BOARD_FILE_NO)
);
COMMIT;
--7) 다음 구조를 갖는 테이블을 생성하세요.
--   T_SNS                              T_SNS_DETAIL                        T_SNS_UPLOADED
--   SNS_NO(PK)    SNS_NM               SNS_NO(PK, FK)   SNS_BEN            SNS_NO(PK, FK)    SNS_UPL_NO(PK)
--     1            페북                   1               4000                   1                  1
--     2           인스타                  2               10000                  1                  2
--     3           트위터                  3               30000                  2                  1
--              


CREATE TABLE T_SNS(
	SNS_NO NUMBER ,
	SNS_NM VARCHAR2(20),
	CONSTRAINT T_SNS_PK PRIMARY KEY(SNS_NO)
);
CREATE TABLE T_SNS_DETAIL(
	SNS_NO NUMBER ,
	SNS_BEN NUMBER ,
	CONSTRAINT T_SNS_DETAIL_PK PRIMARY KEY(SNS_NO),
	CONSTRAINT T_SNS_DETAIL_FK FOREIGN KEY(SNS_NO) REFERENCES T_SNS(SNS_NO)
);
CREATE TABLE T_SNS_UPLOADED(
	SNS_NO NUMBER ,
	SNS_UPL_NO NUMBER ,
	CONSTRAINT T_SNS_UPLOADED_PK PRIMARY KEY(SNS_NO,SNS_UPL_NO),
	CONSTRAINT T_SNS_UPLOADED_FK FOREIGN KEY(SNS_NO) REFERENCES T_SNS(SNS_NO)
);

INSERT INTO T_SNS VALUES (1,'페북');
INSERT INTO T_SNS VALUES (2,'인스타');
INSERT INTO T_SNS VALUES (3,'트위터');

INSERT INTO T_SNS_DETAIL VALUES (1,4000);
INSERT INTO T_SNS_DETAIL VALUES (2,10000);
INSERT INTO T_SNS_DETAIL VALUES (3,30000);

INSERT INTO T_SNS_UPLOADED VALUES (1,1);
INSERT INTO T_SNS_UPLOADED VALUES (1,2);
INSERT INTO T_SNS_UPLOADED VALUES (2,1);

COMMIT;


2                  2